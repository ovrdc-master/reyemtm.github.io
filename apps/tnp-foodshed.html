---
title: TNP Foodshed
layout: app
map: leaflet
template: true
center: 41.2620, -80.8157
zoom: 13
basemap: osm
style: ".leaflet-popup-content{font-size:smaller;}"
loading: false
plugins: route360
---

  var storeData = new omnivore.geojson('/data/tnp/tnp_stores.geojson');
storeData.on('ready', function() {
  buildMap();
});

var types = [];

var myStyle = {
  radius: 8,
  fillOpacity: 0.7,
  weight: 6,
  opacity: 0.6,
  color: "white"
};

//Add Route360 DriveTimes
// set the service key, this is a demo key
// please contact us and request your own key
r360.config.serviceKey = 'MTUSGBLIYJL1CFNANOXX';
r360.config.serviceUrl = 'https://service.route360.net/na_northeast/';

// No we add a layer for the reachability polygons, call the Route360Â°
// web service and render the resulting polygons on the map:
// create the empty layer to add the polygons
var polygonLayer = r360.leafletPolygonLayer({
  strokeWidth: 5
}).addTo(map);
console.log(polygonLayer);

//end route360 pt1

function buildMap() {
  var geojson = storeData.toGeoJSON();
  var spec = new L.geoJson(geojson, {
    filter: function(feature) {
      if (feature.properties.Type == "Specialty") {
        return true
      }
    },
    pointToLayer: function(feature, latlng) {
      return L.circleMarker(latlng, myStyle);
    },
    style: {
      fillColor: "purple"
    }
  });
  var conv = new L.geoJson(geojson, {
    filter: function(feature) {
      if (feature.properties.Type == "Convenience") {
        return true
      }
    },
    pointToLayer: function(feature, latlng) {
      return L.circleMarker(latlng, myStyle);
    },
    style: {
      fillColor: "red"
    }
  });
  var groc = new L.geoJson(geojson, {
    filter: function(feature) {
      if (feature.properties.Type == "Grocery") {
        return true
      }
    },
    pointToLayer: function(feature, latlng) {
      return L.circleMarker(latlng, myStyle);
    },
    style: {
      fillColor: "orange"
    }
  });
  var smarket = new L.geoJson(geojson, {
    filter: function(feature) {
      if (feature.properties.Type == "Supermarket") {
        return true
      }
    },
    pointToLayer: function(feature, latlng) {
      return L.circleMarker(latlng, myStyle);
    },
    style: {
      fillColor: "green"
    }
  });
  var stores = new L.featureGroup().addTo(map);
  stores.addLayer(groc);
  stores.addLayer(spec);
  stores.addLayer(conv);
  stores.addLayer(smarket);

  //add all store types to control
  var control = L.control.layers(null, {
    "Convenience": conv,
    "Specialty": spec,
    "Grocery": groc,
    "Supermarket": smarket
  }, {
    collapsed: false,
  }).addTo(map);

  stores.on('click', function(e) {
    console.log(e);

    //Add route360 isochrones
    polygonLayer.clearLayers();

    // you need to define some options for the polygon service
    var travelOptions = r360.travelOptions();

    // we want to have polygons for 5 to 30 minutes
    travelOptions.setTravelTimes([300, 600, 900, 1800]);
    // and we want to go by foot
    travelOptions.setTravelType('walk');
    var point = new L.marker([e.latlng.lng, e.latlng.lat]);
    travelOptions.addSource(point);
    r360.PolygonService.getTravelTimePolygons(travelOptions, function(polygons) {

        // add the returned polygons to the polygon layer
        // and zoom the map to fit the polygons perfectly (the 'true' parameter)
        polygonLayer.clearAndAddLayers(polygons, true);
      },

      //catch errors in console
      function(status, message) {
        console.log('error');
      });
    });


  map.spin(false);
}

/*function buildMap() {
    map.fitBounds(storeData.getBounds());


    var stores = {},
        type;

    var allPoints = L.geoJson(storeData.toGeoJSON(), {
        pointToLayer: function(feature, latlng) {
            return L.circleMarker(latlng, myStyle);
        },
        style: function(feature) {
            switch (feature.properties.Type) {
                case 'Specialty':
                    return {
                        fillColor: "purple"
                    };
                case 'Convenience':
                    return {
                        fillColor: "red"
                    };
                case 'Grocery':
                    return {
                        fillColor: "orange"
                    };
                case 'Supermarket':
                    return {
                        fillColor: "green"
                    };
            }
        },
        onEachFeature: function(feature, layer) {
            var popup = "";
            for (var k in layer.feature.properties) {
                var v = String(layer.feature.properties[k]);
                popup += '<b>' + k + '</b><br>' + v + '<br>' + '<hr style="margin:5px 0px;">';
            }
            layer.bindPopup(popup);
            type = feature.properties.Type;
            // Initialize the type array if not already set.
            if (typeof stores[type] === "undefined") {
                stores[type] = [];
            }
            stores[type].push(layer);
        }
    });

    var overlaysObj = {},
        typeName,
        typeArray,
        typeLG;

    for (typeName in stores) {
        typeArray = stores[typeName];
        typeLG = L.layerGroup(typeArray);
        typeLG.typeName = typeName;
        overlaysObj[typeName] = typeLG;
    }

    // Create an empty LayerGroup that will be used to emulate adding / removing all stores.
    var allPointsLG = L.layerGroup();
    overlaysObj["All Points"] = allPointsLG;

    var zoomcontrol = L.control.zoom({
        position: 'topright'
    }).addTo(map);
    var control = L.control.layers(null, overlaysObj, {
        collapsed: false,
    }).addTo(map);

    // Make sure the Layers Control checkboxes are kept in sync with what is on map.
    // For some reason this control does not sync its checkboxes with the map state by itself, whereas it does with Leaflet 0.7.x?
    map.on("overlayadd overlayremove layeradd", function(event) {
        var layer = event.layer,
            layertype;

        if (layer === allPointsLG) {
            if (layer.notUserAction) {
                // allPointsLG has been removed just to sync its state with the fact that at least one
                // type is not shown. This event does not come from a user un-ticking the "All points" checkbox.
                layer.notUserAction = false;
                return;
            }
            // Emulate addition / removal of all type LayerGroups when allPointsLG is added / removed.
            for (var typeName in overlaysObj) {
                if (typeName !== "All Points") {
                    if (event.type === "overlayadd") {
                        overlaysObj[typeName].addTo(map);
                    } else {
                        map.removeLayer(overlaysObj[typeName]);
                    }
                }
            }
            control._update();
        } else if (layer.typeName && layer.typeName in overlaysObj) {
            if (event.type === "overlayadd") {
                // Check if all stores are shown.
                for (var typeName in overlaysObj) {
                    layertype = overlaysObj[typeName];
                    if (typeName !== "All Points" && !layertype._map) {
                        // At least one type is not shown, do nothing.
                        return;
                    }
                }
                allPointsLG.addTo(map);
                control._update();
            } else if (event.type === "overlayremove" && allPointsLG._map) {
                // Remove allPointsLG as at least one type is not shown.
                // But register the fact that this is purely for updating the checkbox, not a user action.
                allPointsLG.notUserAction = true;
                map.removeLayer(allPointsLG);
                control._update();
            }
        }
    });

    allPointsLG.addTo(map);

    //console.log(storeData);
    map.spin(false);
}


*/
